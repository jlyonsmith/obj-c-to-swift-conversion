The key enabler of Swift conversions are the Xcode bridging headers, of which there are _two_.  In addition the `@objc` attribute is used to expose Swift classes, protocols, and enums to Objective-C code.  This is essential as you will be converting your code file-by-file.

Firstly, _beware of cross dependencies_.  You _are_ going to create them.  For example, say you just finished converting `Protocol.h` into `Protocol.swift`.  Now:

- `Xxx-Bridging-Header.h` contains `DependsOnProtocol.h`
- `Xxx-Swift.h` contains `Protocol.swift` (as Objective-C) which is inherited by  `DependsOnProtocol.m`

You'll get a build error and a headache.  In this case the solution is to keep going and convert `DependsOnProtocol.h/.m` as well.

Secondly, _beware of rebuild issues_.  In Xcode 7.1 changing the `Xxx-Bridging-Header.h` does not always correctly build all dependencies.  Until this is fix you may need to _Clean_ and _Build_.


#### The `Xxx-Swift.h` Header

This header is auto-generated by the Swift compiler and exposes Swift code to Objective-C.

#### The `@objc` Attribute

Any Swift class that needs to be accessible from Swift needs the `@objc` attribute.  Adding this attribute causes the class/protocol/enum to be added to the `Xxx-Swift.h` bridging header (see above).

#### The `Xxxx-Bridging-Header.h` Header

This header is manually maintained by _you_ and needs to include any Objective-C classes that need to be made available to the Swift compiler.  Put as little as possible in here and remove things as you convert.

If you use Objective-C Cocoapods, this is where they will live, probably forever or until Swift versions of the libraries become available.
